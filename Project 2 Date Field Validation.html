<!DOCTYPE html>

<!--

DESCRIPTION/NOTES/CHANGELOG:-
--------------------------------------------------------------------------------------------

A simple date validation tool, for any basic string input element(s), that validates dynamically as the end-user types in a date. It is designed to be as compatiable (both backwards & cross-browser) as possible, while covering all user inputs that could be attempted when typing a date (both valid or invalid).

============================================================================================

Remote Name: https://github.com/tberey/date-validation
Branch Name: https://github.com/tberey/test/tree/# (None)

============================================================================================

1) Add drop down for US/other formats input functionality, to then output the UK date with the others.


2) Make it so that the button is the only way to focus and blur field. !(In-Progress)!


3) Add IE 11 and lower support, by replacing ES6 with ES5.


Note: USED SELENIUM FOR CROSS-USER AGENT TESTING.


-->

<html>
	<head>
		<!-- Set a Responsively scaled viewport, and assign Metadata. -->
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width,initial-scale=1">
			<title>Input Field Date Validation</title>
		<meta name="author" content="TB">
		<meta name="description" content="Date, Input, Field, Validation, JavaScript, HTML, CSS, Regexp">
		<!-- Begin Styling. -->
		<style type="text/css"> /* Set in-page CSS Attributes/Properties. */
			body {
				display: flex;
			}
			
			button {
				pointer-events: auto;
				background-color: rgb(23, 124, 207);
 				border: none;
				border-radius:50%;
 				color: white;
  				padding: 15px 32px;
  				text-align: center;
  				text-decoration: none;
  				display: inline-block;
 				font-size: 10px;
 				margin: 4px 2px;
				cursor: pointer;
			}
			
			input[type=text] {
				width: 30%;
				padding: 5px;
				margin: 20px;
				box-sizing: border-box;
				border: none;
				border-bottom: 3px solid rgb(161, 1, 1);
				color: white;
				background-color: rgb(13, 112, 99);
				
			}
			
			input[type=text]:focus {
				width: 50%;
				color: black;
				border: 3px solid rgb(32, 221, 32);
				background-color: #89f885;
				
			}
			
			input::placeholder {
				color: rgb(161, 1, 1);
			}
			
			#form {
				flex: 1;
				width: 40%;
				border: 3px solid rgb(19, 0, 128);
				overflow: visible;
				background-color: rgb(13, 112, 99);
				float: left;
				pointer-events: none;
			}
			
			#output {
				flex: 1;
				width: 40%;
				border: 3px solid rgb(4, 77, 8);
				background-color: rgb(91, 100, 12);
				float: left;
				margin-left: 3px;
			}
		</style>
		<!-- End of Styling. -->
	</head>
	<!---------------------------------------------------------------------------------------------------------------->
	<body>
		<!-- Left/Blue input side of document area, where the targeted element nests. -->
		<div id="form">
			<button onclick="!buttonBool ? inputField.focus() : inputField.blur();">Change Date</button>
			<input name="DateInput" type="text" placeholder="dd/mm/yyyy" onfocus="this.select();">
			<p>Please enter a date in a UK format.</p>
			<p>Anything similar to "d/m/y".</p>
		</div>
		<!-- Right/Green side of document area, where the output is. -->
		<div id="output">
			<p><b>Output:-</b></p>
			</br>
			<p id="d1"><i>Enter a date in the field on the left...</i></p>
			<hr>
		</div>
		<!-- Begin Scripting. -->
		<script type="text/javascript">
			// Global Declaration Space.
			let inputField = document.getElementsByName('DateInput')[0], outputParentEl = document.getElementById('output'), buttonBool;
			
			// Call the 'initialised' function, when document is ready/fully-loaded.
			if (document.addEventListener) document.addEventListener("DOMContentLoaded", initialised, false);
			else if (document.attachEvent) document.attachEvent("onreadystatechange", initialised);
			else window.onload = initialised;
			
			// Set/Unset Event Listeners within this function (some nested). The active listeners will call relevant the function, based on action/event.
			function initialised() {
				inputField.addEventListener('focus', () => {
					
					inputField.addEventListener('keydown', () => {
						keyDownEv(event);
					});
					
					inputField.addEventListener('keyup', () => {
						checkInputtedChr(inputField);
						outputBox();
					});
				});
				
				inputField.addEventListener('blur', () => {
					outputBox(true); // Pass through truthy argument to indicate field has no focus, so conditional will determine incomplete dates are now unaccepatble.
					
					inputField.removeEventListener('keydown', () => {
						keyDownEv(event);
					});
					
					inputField.removeEventListener('keyup', () => {
						checkInputtedChr(inputField);
						outputBox();
					});
				});
			}
			
			// 1) Some generic user input error handling, in that it; (i) disables certain navigation keys, and (ii) by passing the keydown event as an argument, prevents a key from being held down and producing many characters in the field.
			// 2) Removes our created elements in the output div/area, if the date is changed in any way (so to partially-initialise output).
			function keyDownEv(event) {
				if ([17, 36, 37, 40].indexOf(event.keyCode) > -1) { // [ctrl, home, left arrow, down arrow]
					event.preventDefault();
				} else if (event.repeat) { 
					inputField.value = inputField.value.substring(0, inputField.value.length - 1);
				} else if (outputParentEl.childNodes.length > 11) {
					['USDate','ISODate','fullDate','UADate'].forEach((val) => {
						outputParentEl.removeChild(document.getElementById(val));
					});
				}
			}
			
			//Function is called on a key-by-key press basis, to check each inputted character is valid (through a series of conditionals, and one overarching switch conditional). If invalid, deletes said character.
			function checkInputtedChr() {
				let fieldVal = inputField.value;
				let n = fieldVal.length
				let chr = fieldVal[n-1], prevChr = fieldVal[n-2], thirdReversedChr = fieldVal[n-3];
				let int = parseInt(chr);
				
				//Function is called whenever an invalid character is conditionally detected during the date inputting, and simply deletes it. Further more when truthy argument is passed in with the call, the conditional with replace the removed character with a actual date seperator (and will match the user's seperator if there is one already present).
				function delChr(a) {
					inputField.value = fieldVal.substring(0, n-1);
					
					if (a) {
						let seperator = fieldVal[fieldVal.search(/[-/.]/)] || '/';
						inputField.value = inputField.value + seperator;
					}
				}
				
				// Bulk of the validation checks occur using this switch condtional statement, which uses a case for each instance of a character being enetered into field.
				switch(true) {
					case (n < 3):
						if ((n == 1 && isNaN(int)) ||
						(n == 2 && ((prevChr == 3 && int > 1) ||
						(prevChr == 0 && (isNaN(int) || int == 0))))) {
							delChr();
						} else if (n == 2 && ['/','-','.'].indexOf(chr) == -1 && (isNaN(int) || prevChr > 3)) {
							delChr(1);
						}
						break;
					
					case (n == 3):
						if (isNaN(prevChr) && isNaN(int)) {
							delChr();
						} else if (!isNaN(prevChr) && ['/','-','.'].indexOf(chr) == -1) {
							delChr(1);
						}
						break;
						
					case (n == 4):
						if ((isNaN(prevChr) && isNaN(int)) || (prevChr == 0 && (isNaN(int) || int == 0))) {
							delChr();
						}else if ((prevChr == 1 && ['/','-','.'].indexOf(chr) == -1 && (int > 2 || isNaN(int))) ||
						(prevChr > 1 && ['/','-','.'].indexOf(chr) == -1)) {
							delChr(1);
						}
						break;
						
					case (n == 5):
						if ((isNaN(prevChr) && isNaN(int)) ||
						(prevChr == 1 && (int > 2 ||(!isNaN(thirdReversedChr) && !isNaN(int)))) ||
						(prevChr == 0 && ((isNaN(thirdReversedChr) && (isNaN(int) || int == 0)) || (!isNaN(thirdReversedChr) && !isNaN(int))))) {
							delChr();
						} else if ((prevChr < 2 && ['/','-','.'].indexOf(chr) == -1 && isNaN(int)) ||
						(prevChr > 1 && ['/','-','.'].indexOf(chr) == -1)) {
							delChr(1);
						}
						break;
					
					case (n == 6):
						if ((isNaN(prevChr) && isNaN(int)) ||
						(isNaN(thirdReversedChr) && isNaN(int))) {
							delChr();
						} else if (!isNaN(prevChr) &&
						((isNaN(thirdReversedChr) && isNaN(int)) || (!isNaN(thirdReversedChr) && ['/','-','.'].indexOf(chr) == -1))) {
							delChr(1);
						}
						break;
					
					case (n < 11):
						if ((n < 9 && isNaN(int)) ||
						(n == 9 && (isNaN(int) || fieldVal.lastIndexOf("/") == 3)) ||
						(n == 10 && (isNaN(int) || fieldVal.lastIndexOf("/") == 4))) {
							delChr();
						}
						break;
					
					default:
						delChr();
						inputField.blur();
				}
				
				// Conditional block, that deals with any invalid input (but) that conflicts with any of the above conditions in the switch statement, or any other invalid entries that can be determined at any and all time during the user input. Checking for two consecutive characters that are not numbers, or if a 'keyboard mash' has occured.
				if (inputField.value.length > 1 &&
				inputField.value[n-1] !== undefined &&
				inputField.value[n-1].search(/[-/.]/) > -1 &&
				fieldVal.substring(0, n-1).search(/[-/.]/) > -1) {
					delChr(1);
				} else if (inputField.value.search(/([A-Z])/i) > -1 || inputField.value.search(/[\D]{2}/g) > -1) {
					inputField.value = ''; // This is necessary as this condition being met indicates that a load of keys at the same time (mash the keyboard) and bypassing the above key-press by key-press checks on the preceding characters inputted.
				}
			}
			
			// Construct the output div/area further, by setting the instructional text dynamically, while also building the html elements that will host the further dates/data manipulated from the user's entered date, when it has been completed. Also counters incomplete dates, by emptying the field. Default parameter is falsy for passing through during field input to avoid meeting the conditions for this (incomplete dates wouldn't be deleted at this early stage).
			function outputBox(blur=false) {
				
				if (inputField.value.length == 0) {
					inputField.value = '';
					document.getElementById('d1').innerHTML = '<i>Enter a date in the field on the left...</i>';
				} else if (blur &&
				(inputField.value.length < 6 || isNaN(inputField.value[inputField.value.length - 2]) || isNaN(inputField.value[inputField.value.length - 4]))) {
					inputField.value = '';
					document.getElementById('d1').innerHTML = '<i>Invalid Date Entered!</i>';
				} else {
					document.getElementById('d1').innerHTML = `Entered Date: <b>"${inputField.value}"</b>`;
					
					if (blur && inputField.value.split(/[-/.]/).length == 3 && outputParentEl.childNodes.length < 10) {
						let dateConstistuentsArray = inputField.value.split(/[-/.]/);
						for (let i = 0; i < 3; i++) {
							switch (dateConstistuentsArray[i].length) {
								case 1:
									dateConstistuentsArray[i] = '0' + dateConstistuentsArray[i];
									break;
							}
						}
						
						let dd = dateConstistuentsArray[0], mm = dateConstistuentsArray[1], yyyy = dateConstistuentsArray[2];
						let userInputDate = (new Date(yyyy, (mm-1), dd).toUTCString()).split(' 00:00:00 ');
						let usDate = document.createElement('P'), // Build the addtional html elements, to be appended to document body.
						isoDate = document.createElement('P'), fullDate = document.createElement('P'), uaDate = document.createElement('P');
						
						usDate.setAttribute("id", "USDate");
						usDate.innerHTML = `US Date: <b>${mm}-${dd}-${yyyy}</b>`;
						
						isoDate.setAttribute("id", "ISODate");
						isoDate.innerHTML = `ISO (International Standard) Date: <b>${yyyy}-${mm}-${dd}</b>`;
						
						fullDate.setAttribute("id", "fullDate");
						fullDate.innerHTML = `Full Date Entered:</br><b>${userInputDate[0]} ${userInputDate[1]}</b>`;
						
						uaDate.setAttribute("id", "UADate");
						uaDate.innerHTML = `Your Local Time (<i><u>UTC ${-(Math.floor(new Date().getTimezoneOffset()/60)) || '+/-0'} hours</u></i>):</br><b>${new Date()}</b>`;
						
						[usDate,isoDate,fullDate,uaDate].forEach((val) => {
							outputParentEl.appendChild(val); // Append the new elements to body, once date is complete and validated.
						});
					}
				}
			}
		</script>
		<!-- End of Scripting. -->
	</body>
</html>
<!-- End of HTML. -->